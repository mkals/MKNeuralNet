//
//  MKMatrix.swift
//  MKNeuralNet
//
//  Created by Marie Kals on 03.03.2016.
//  Copyright © 2016 no.kals.m. All rights reserved.
//

import Foundation
import Accelerate

protocol Number: Equatable, Comparable {
    func +(lhs: Self, rhs: Self) -> Self
    func -(lhs: Self, rhs: Self) -> Self
    func *(lhs: Self, rhs: Self) -> Self
    func /(lhs: Self, rhs: Self) -> Self
    prefix func -(num: Self) -> Self
}

extension Int: Number {}
extension Double: Number {}

extension Matrix where T:Double {
    
    /**
     Initializes new matrix with doubles between 0 and 1
     - Parameters:
        - rows: number of rows that the matrix is to have
        - columns: number of columns that the matrix is to have
     - Precondition: rows and columns must exceed 0
     - Returns: matrix with provided dimensions and double values between 0 and 1
     */
    init (rows: Int, columns: Int) {
        return Matrix.init(rows: rows, columns: columns, arc4random)
    }
}

struct Matrix <T: Number> : Equatable {
    
    /**
     array to store matrix values: row one first, then row two etc.
     */
    private let array: [T]
    
    let rows: Int
    let columns: Int

    
    /**
     Initializes new matrix with given number of rows and columns and containing provided values
     - Parameters:
        - rows: number of rows that the matrix is to have
        - columns: number of columns that the matrix is to have
        - array: array containing elements to be placed into array, starting with row one, then row two etc.
     - Precondition: rows * columns = array.count, rows and columns must exceed 0
     - Returns: matrix with privided size and values
     */
    init (rows: Int, columns: Int, array: [T]) {
        
        assert(array.count == rows * columns)
        
        self.array = array
        
        self.rows = rows
        self.columns = columns
    }
 
    /**
     Initializes new matrix with given number of rows and columns and providing numbers generated by passed function
     - Parameters:
        - rows: number of rows that the matrix is to have
        - columns: number of columns that the matrix is to have
        - functionToGenerateNumbers: function that returns a number to be placed in the matrix, starting with row one, then row two etc.
     - Precondition: rows and columns must exceed 0
     - Returns: matrix with provided size and values
     */
    init (rows: Int, columns: Int, functionToGenerateNumbers: () -> T) {
        
        self.array = [T]()
        
        for _ in 1 ... rows * columns {
            self.array.append(functionToGenerateNumbers())
        }
        
        self.rows = rows
        self.columns = columns
    }
    
    /**
     Accesses elements of matrix
     - Parameters:
        - row: row index
        - column: column index
     - Precondition: row and column must exceed 0 and not be larger than total number of rows and columns respectivley
     - Returns: number stored at spesifyed location
     */
    subscript (row: Int, column: Int) -> T {
        return array[ (row - 1) * self.columns + (column - 1) ] //-1 as first index of matrix is 1,1 and first index of array is 0
    }
    
    /**
     Elementwise operation on all numbers in matrix. Performs the function on all elements in the matrix and resturns .
     - Parameters:
        - operation: function to be performed on all elements of matrix
     - Returns: result as a new matrix
     */
    func performElementOperation(operation: T -> T) -> Matrix {
        
        var returnArray = [T]()
        
        for number in array {
            returnArray.append(operation(number))
        }
        
        return Matrix.init(rows: self.rows, columns: self.columns, array: returnArray)
    }
    
    /**
     Matrix transpose
     - Returns: transpose of matrix
     */
    func transpose() -> Matrix {
        
        let newRows = self.columns
        let newColumns = self.rows
        
        var result = [T]()
        
        for column in 1...columns {
            for row in 1...rows {
                result.append(self[row, column])
            }
        }
        
        return Matrix.init(rows: newRows, columns: newColumns, array: result)
    }
}


//MARK: Function implementation

/**
 Equality comparison
 - Returns: weather matrices are equal (rows, columns and contained values are compared)
 */
func == <T:Number>(lhs: Matrix<T>, rhs: Matrix<T>) -> Bool {
    guard lhs.array == rhs.array else {return false}
    guard lhs.rows == rhs.rows else {return false}
    guard lhs.columns == rhs.rows else {return false}
    return true
}

/**
 Unary negative
 - Returns: matrix of same dimensionality but where every element has the opposite sign
 */
prefix func - <T:Number>(matrix: Matrix<T>) -> Matrix<T> {
    return Matrix.init(rows: matrix.rows, columns: matrix.rows, array: matrix.array.map{ -$0 })
}


infix operator • { associativity left precedence 120}

/**
 Matrix multiplication A•B=C
 - Precondition: 
    - A must be of dimensionality M-by-P
    - B must be of dimensionality P-by-N
 - Returns: C, matrix of dimensionality M-by-N
 */
func • (lhs: Matrix<Double>, rhs: Matrix<Double>) -> Matrix<Double> {
    
    assert(lhs.columns == rhs.rows)
    
    let m = lhs.rows
    let n = rhs.columns
    let p = lhs.columns
    
    var product = [Double]()
    
    vDSP_mmulD(lhs.array, 1, rhs.array, 1, &product, 1, UInt(m), UInt(n), UInt(p))
    
    return Matrix.init(rows: m, columns: n, array: product)
}


/**
 Elementwise multiplication A*B=C
 - Precondition: A and B must have same number of rows and columns
 - Returns: C, matrix of dimensionality equal to that of A and B
 */
func * <T:Number>(lhs: Matrix<T>, rhs: Matrix<T>) -> Matrix<T> {
    assert(lhs.rows == rhs.rows && lhs.columns == rhs.columns)
    return Matrix.init(rows: lhs.rows, columns: lhs.columns, array: Array(zip(lhs.array, rhs.array)).map { $0 * $1 })
}

/**
 Matrix addition A+B=C
 - Precondition: A and B must have same number of rows and columns
 - Returns: C, matrix of dimensionality equal to that of A and B
 */
func + <T:Number>(lhs: Matrix<T>, rhs: Matrix<T>) -> Matrix<T> {
    assert(lhs.rows == rhs.rows && lhs.columns == rhs.columns)
    return Matrix.init(rows: lhs.rows, columns: lhs.columns, array: Array(zip(lhs.array, rhs.array)).map { $0 + $1 })
}

/**
 Matrix subtraction A-B=C
 - Precondition: A and B must have same number of rows and columns
 - Returns: C, matrix of dimensionality equal to that of A and B
 */
func - <T:Number>(lhs: Matrix<T>, rhs: Matrix<T>) -> Matrix<T> {
    assert(lhs.rows == rhs.rows && lhs.columns == rhs.columns)
    return lhs + (-rhs)
}
